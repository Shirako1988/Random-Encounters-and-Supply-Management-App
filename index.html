<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Random Encounters ‚Äî Spieltisch-Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'bg-primary': '#0f1724',
              'bg-secondary': '#071022',
              'card': '#0b1220',
              'muted': '#9aa6b2',
              'accent': '#7dd3fc',
              'good': '#34d399',
              'bad': '#fb7185',
              'glass': 'rgba(255, 255, 255, 0.03)',
              'border-color': 'rgba(255, 255, 255, 0.04)',
              'input-bg': 'rgba(255, 255, 255, 0.08)'
            }
          }
        }
      }
    </script>
    
    <!-- React & ReactDOM (Global CDN) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-gradient-to-b from-bg-secondary to-[#07182a] text-[#e6eef6] font-sans antialiased">
    <div id="root"></div>

    <!-- MAIN APP CODE EMBEDDED -->
    <script type="text/babel">
      const { useState, useEffect, useMemo, useRef } = React;
      const { createRoot } = ReactDOM;

      // ==========================================
      // CONSTANTS
      // ==========================================

      const DEFAULTS = {
        day: {
          "Stra√üe": {hostile:[1,3], neutral:[4,6], poi:[7,8]},
          "Wildnis": {hostile:[1,5], neutral:[6,8], poi:[9,10]},
          "Unbekannt": {hostile:[1,5], neutral:[6,8], poi:[9,22]},
          "Feindgebiet": {hostile:[1,10], neutral:[11,12], poi:[13,15]},
          "Gesucht": {hostile:[1,12], neutral:[13,14], poi:[15,17]},
          "Custom": {hostile:[0,0], neutral:[0,0], poi:[0,0]}
        },
        night: {
          "Stra√üe": {basis:[1,1], light:1},
          "Wildnis": {basis:[1,3], light:1},
          "Unbekannt": {basis:[1,3], light:1},
          "Feindgebiet": {basis:[1,6], light:1},
          "Gesucht": {basis:[1,10], light:2},
          "Custom": {basis:[0,0], light:0}
        }
      };

      const TERRAIN_MAP = {
          road:'Stra√üe', 
          wilderness:'Wildnis', 
          unknown:'Unbekannt', 
          enemy:'Feindgebiet', 
          wanted:'Gesucht', 
          custom:'Custom'
      };

      const VISION_NAMES = {
          none:'Kein Darkvision', 
          darkvision:'Darkvision', 
          magic:'Magisches Darkvision'
      };

      const CONSUMPTION_RATES = {
          'Tiny':       { food: 0.25, water: 0.25, feed: 0.06 }, 
          'Small':      { food: 1,    water: 1,    feed: 0.25 }, 
          'Medium':     { food: 1,    water: 1,    feed: 0.25 }, 
          'Large':      { food: 4,    water: 4,    feed: 1.0  }, 
          'Huge':       { food: 16,   water: 16,   feed: 4.0  }, 
          'Gargantuan': { food: 64,   water: 64,   feed: 16.0 }  
      };

      const FEED_WEIGHT_LB = 10; // 1 Unit feed = 10 lbs

      // ==========================================
      // HELPER FUNCTIONS
      // ==========================================
      const generateId = () => Math.random().toString(36).substr(2, 9);
      const rnd = (n) => Math.floor(Math.random() * n) + 1;
      const parseInts = (str) => str.split(/[,;\s]+/).map(x => parseInt(x, 10)).filter(x => !isNaN(x));
      const avg = (arr) => arr.length ? arr.reduce((s, x) => s + x, 0) / arr.length : 0;
      const safeFloat = (val) => {
          const num = parseFloat(val);
          return isNaN(num) ? 0 : num;
      };

      // ==========================================
      // COMPONENTS
      // ==========================================

      const Modal = ({ config, onClose }) => {
          if (!config.isOpen) return null;

          return (
              <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/70 backdrop-blur-sm p-4 animate-in fade-in duration-200">
                  <div className="bg-card border border-border-color rounded-xl shadow-2xl max-w-md w-full p-6 transform transition-all scale-100">
                      <h3 className="text-xl font-bold mb-4 text-white">{config.title}</h3>
                      <div className="text-muted mb-6 whitespace-pre-wrap text-sm leading-relaxed">
                          {config.message}
                      </div>
                      <div className="flex justify-end gap-3">
                          {config.type === 'confirm' && (
                              <button 
                                  onClick={onClose} 
                                  className="px-4 py-2 rounded-lg border border-border-color text-muted hover:bg-glass hover:text-white transition-colors"
                              >
                                  Abbrechen
                              </button>
                          )}
                          <button 
                              onClick={() => {
                                  if (config.onConfirm) config.onConfirm();
                                  onClose();
                              }} 
                              className="px-4 py-2 rounded-lg bg-accent text-bg-secondary font-bold shadow-md hover:opacity-90 transition-opacity"
                          >
                              {config.type === 'confirm' ? 'Best√§tigen' : 'OK'}
                          </button>
                      </div>
                  </div>
              </div>
          );
      };

      const SettingsCard = ({ settings, setSettings, onTravelRoll, onRestRoll, onResetAll }) => {
          const handleSettingsChange = (key, value) => {
              setSettings(prev => ({ ...prev, [key]: value }));
          };

          const handleWatchCountChange = (e) => {
              const count = Math.max(1, Math.min(8, parseInt(e.target.value, 10) || 1));
              setSettings(prev => {
                  const newWatches = [...prev.watches];
                  while (newWatches.length < count) {
                      newWatches.push({ name: `Wache ${newWatches.length + 1}`, vision: 'none', pp: 12 });
                  }
                  return {
                      ...prev,
                      watchCount: count,
                      watches: newWatches.slice(0, count)
                  };
              });
          };

          const handleWatchChange = (index, field, value) => {
              setSettings(prev => {
                  const newWatches = [...prev.watches];
                  newWatches[index] = { ...newWatches[index], [field]: value };
                  return { ...prev, watches: newWatches };
              });
          };

          return (
              <div className="bg-card rounded-xl p-4 shadow-lg">
                  <h3 className="text-xl font-bold mb-4">Einstellungen</h3>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div>
                          <label className="block text-sm text-muted mb-1">Gel√§nde / Situation</label>
                          <select value={settings.terrain} onChange={e => handleSettingsChange('terrain', e.target.value)} className="w-full p-2 rounded-lg border border-border-color bg-bg-secondary text-white focus:ring-accent focus:border-accent">
                              <option value="road">Stra√üe (zivilisiert)</option>
                              <option value="wilderness">Abseits der Stra√üe (Wildnis)</option>
                              <option value="unknown">Unbekanntes Gebiet</option>
                              <option value="enemy">Feindgebiet</option>
                              <option value="wanted">Gesucht (hoher Fahndungsdruck)</option>
                              <option value="custom">Custom</option>
                          </select>
                      </div>
                      <div className="grid grid-cols-2 gap-4">
                           <div>
                              <label className="block text-sm text-muted mb-1">Reise-Tempo</label>
                              <select value={settings.pace} onChange={e => handleSettingsChange('pace', e.target.value)} className="w-full p-2 rounded-lg border border-border-color bg-bg-secondary text-white">
                                  <option value="normal">Normal</option>
                                  <option value="fast">Schnell (Gruppen-PP halbiert)</option>
                                  <option value="slow">Langsam (Gruppen-PP +50%)</option>
                              </select>
                          </div>
                           <div>
                              <label className="block text-sm text-muted mb-1">Fahrzeug?</label>
                              <select value={settings.vehicle} onChange={e => handleSettingsChange('vehicle', e.target.value)} className="w-full p-2 rounded-lg border border-border-color bg-bg-secondary text-white">
                                  <option value="no">Nein</option>
                                  <option value="yes">Ja (Stealth Nachteil)</option>
                              </select>
                          </div>
                      </div>
                  </div>

                  <div className="flex gap-2 mt-4">
                      <button onClick={onTravelRoll} className="flex-1 bg-gradient-to-r from-accent to-sky-500 text-bg-secondary font-bold py-2 px-4 rounded-lg shadow-md hover:opacity-90 transition-opacity">Travel Roll</button>
                      <button onClick={onResetAll} className="bg-transparent border border-border-color text-muted py-2 px-4 rounded-lg hover:bg-glass transition-colors">Reset All</button>
                  </div>
                  
                  <hr className="border-border-color my-6" />

                  <h4 className="text-lg font-bold mb-4">Long Rest (Nacht-Encounters)</h4>
                  <div className="grid grid-cols-2 gap-4">
                       <div>
                          <label className="block text-sm text-muted mb-1">Anzahl Wachschichten</label>
                          <input type="number" min="1" max="8" value={settings.watchCount} onChange={handleWatchCountChange} className="w-full p-2 rounded-lg border border-border-color bg-input-bg text-white" />
                      </div>
                      <div>
                          <label className="block text-sm text-muted mb-1">Stunden mit Licht (0-8)</label>
                          <input type="number" min="0" max="8" value={settings.lightHours} onChange={e => handleSettingsChange('lightHours', parseInt(e.target.value, 10))} className="w-full p-2 rounded-lg border border-border-color bg-input-bg text-white" />
                      </div>
                  </div>

                  <div className="mt-4 space-y-2">
                      {settings.watches.map((watch, index) => (
                          <div key={index} className="grid grid-cols-1 md:grid-cols-[auto,1fr,1fr,120px] gap-3 items-end p-3 bg-glass rounded-lg">
                              <div className="font-bold text-accent self-center">Wache {index + 1}</div>
                              <div>
                                  <label className="text-xs text-muted">Charakter</label>
                                  <input value={watch.name} onChange={e => handleWatchChange(index, 'name', e.target.value)} placeholder="Name" className="w-full p-1.5 text-sm rounded-md border border-border-color bg-input-bg text-white" />
                              </div>
                              <div>
                                  <label className="text-xs text-muted">Vision-Typ</label>
                                  <select value={watch.vision} onChange={e => handleWatchChange(index, 'vision', e.target.value)} className="w-full p-1.5 text-sm rounded-md border border-border-color bg-bg-secondary text-white">
                                      {Object.entries(VISION_NAMES).map(([key, name]) => <option key={key} value={key}>{name}</option>)}
                                  </select>
                              </div>
                              <div>
                                  <label className="text-xs text-muted">Passive Perception</label>
                                  <input type="number" min="1" max="30" value={watch.pp} onChange={e => handleWatchChange(index, 'pp', parseInt(e.target.value, 10))} className="w-full p-1.5 text-sm rounded-md border border-border-color bg-input-bg text-white" />
                              </div>
                          </div>
                      ))}
                  </div>
                  
                  <div className="flex gap-2 mt-4">
                      <button onClick={onRestRoll} className="flex-1 bg-gradient-to-r from-accent to-sky-500 text-bg-secondary font-bold py-2 px-4 rounded-lg shadow-md hover:opacity-90 transition-opacity">Long Rest w√ºrfeln</button>
                  </div>
              </div>
          );
      };

      const LogCard = ({ log, result, onResetLog }) => {
          return (
              <div className="bg-card rounded-xl p-4 shadow-lg flex flex-col">
                  <div className="flex justify-between items-center mb-2">
                      <h3 className="text-xl font-bold">Log & Ergebnisse</h3>
                      <button onClick={onResetLog} className="bg-transparent border border-border-color text-muted text-sm py-1 px-3 rounded-lg hover:bg-glass transition-colors">Log leeren</button>
                  </div>

                  <div className="p-3 mb-2 rounded-lg bg-glass text-white" dangerouslySetInnerHTML={{ __html: result.replace(/(\b(hostile|neutral|poi|gewinnen|verlieren|erkannt|verpasst|verhindert|√ºberrascht)\b)/gi, '<strong class="text-accent">$1</strong>') }} />
                  
                  <div className="flex-grow h-64 overflow-y-auto p-2 rounded-lg bg-gradient-to-b from-[rgba(255,255,255,0.01)] to-[rgba(255,255,255,0.02)] font-mono text-sm text-muted">
                      {log.map((entry, index) => (
                          <p key={index} className="whitespace-pre-wrap">{entry}</p>
                      ))}
                  </div>
              </div>
          );
      };

      const MatrixInput = ({ value, onChange, onReset }) => (
          <div className="flex items-center gap-1 justify-center">
              <input 
                  type="number" 
                  value={value} 
                  onChange={e => onChange(parseInt(e.target.value, 10) || 0)}
                  className="w-14 p-1 text-center rounded-md border border-border-color bg-input-bg text-white"
              />
              <button onClick={onReset} title="Reset to default" className="text-muted hover:text-accent transition-colors">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h5M20 20v-5h-5M4 4l16 16" /></svg>
              </button>
          </div>
      );

      const MatrixEditor = ({ matrix, setMatrix, addLog, triggerModal }) => {
          const handleDayMatrixChange = (area, type, index, value) => {
              setMatrix(prev => {
                  const newMatrix = JSON.parse(JSON.stringify(prev));
                  newMatrix.day[area][type][index] = value;
                  
                  const ranges = ['hostile', 'neutral', 'poi']
                      .map(t => ({ name: t, from: newMatrix.day[area][t][0], to: newMatrix.day[area][t][1] }))
                      .sort((a, b) => a.from - b.from);
                  
                  let changed = false;
                  for (let i = 0; i < ranges.length - 1; i++) {
                      const current = ranges[i];
                      const next = ranges[i + 1];
                      if (current.to >= next.from && current.to > 0 && next.from > 0) {
                          const gap = current.to - next.from + 1;
                          newMatrix.day[next.name][0] += gap;
                          newMatrix.day[next.name][1] += gap;
                          changed = true;
                      }
                  }

                  if (changed) addLog(`Matrix: Bereiche f√ºr '${area}' automatisch angepasst.`);
                  return newMatrix;
              });
          };
          
          const handleNightMatrixChange = (area, type, value, index) => {
               setMatrix(prev => {
                  const newMatrix = JSON.parse(JSON.stringify(prev));
                  
                  if (type === 'basis' && (index === 0 || index === 1)) {
                      newMatrix.night[area][type][index] = value;
                  } else if (type === 'light') {
                      newMatrix.night[area][type] = value;
                  }
                  return newMatrix;
              });
          }

          const resetMatrix = () => {
              triggerModal(
                  'confirm', 
                  'Matrix Reset', 
                  'M√∂chtest du wirklich die gesamte Encounter-Matrix auf die Standardwerte zur√ºcksetzen?',
                  () => {
                      setMatrix(JSON.parse(JSON.stringify(DEFAULTS)));
                      addLog('Gesamte Matrix auf Standardwerte zur√ºckgesetzt.');
                  }
              );
          };

          return (
              <section className="bg-card rounded-xl p-4 shadow-lg mt-4">
                  <div className="flex flex-col sm:flex-row justify-between sm:items-center mb-4 gap-2">
                      <h3 className="text-xl font-bold">Begegnungs-Matrix (editierbar)</h3>
                      <button onClick={resetMatrix} className="bg-transparent border border-border-color text-muted py-1 px-3 rounded-lg hover:bg-glass transition-colors text-sm">üîÑ Gesamte Matrix zur√ºcksetzen</button>
                  </div>
                  <div className="text-sm p-3 bg-glass rounded-lg mb-4 text-muted">
                      <strong>Anleitung:</strong> Tragen Sie die W√ºrfelwerte ein (d100). Bei √Ñnderungen werden andere Bereiche automatisch angepasst, um √úberschneidungen zu vermeiden.
                  </div>

                  <div className="grid grid-cols-1 xl:grid-cols-2 gap-6">
                      <div>
                          <h4 className="font-bold mb-2">Tag-Encounters</h4>
                          <div className="overflow-x-auto">
                              <table className="w-full border-collapse text-sm text-center">
                                  <thead className="text-muted">
                                      <tr>
                                          <th className="p-2 border border-border-color text-left">Gebiet</th>
                                          <th className="p-2 border border-border-color" colSpan={2}>Hostile (d100)</th>
                                          <th className="p-2 border border-border-color" colSpan={2}>Neutral (d100)</th>
                                          <th className="p-2 border border-border-color" colSpan={2}>POI (d100)</th>
                                      </tr>
                                  </thead>
                                  <tbody>
                                      {Object.entries(matrix.day).map(([area, data]) => (
                                          <tr key={area}>
                                              <td className="p-2 border border-border-color text-left font-semibold">{area}</td>
                                              {['hostile', 'neutral', 'poi'].flatMap(type => [
                                                  <td key={`${area}-${type}-0`} className="p-1 border border-border-color"><MatrixInput value={data[type][0]} onChange={v => handleDayMatrixChange(area, type, 0, v)} onReset={() => handleDayMatrixChange(area, type, 0, DEFAULTS.day[area][type][0])} /></td>,
                                                  <td key={`${area}-${type}-1`} className="p-1 border border-border-color"><MatrixInput value={data[type][1]} onChange={v => handleDayMatrixChange(area, type, 1, v)} onReset={() => handleDayMatrixChange(area, type, 1, DEFAULTS.day[area][type][1])} /></td>
                                              ])}
                                          </tr>
                                      ))}
                                  </tbody>
                              </table>
                          </div>
                      </div>
                      <div>
                          <h4 className="font-bold mb-2">Nacht-Encounters</h4>
                          <div className="overflow-x-auto">
                               <table className="w-full border-collapse text-sm text-center">
                                  <thead className="text-muted">
                                      <tr>
                                          <th className="p-2 border border-border-color text-left">Gebiet</th>
                                          <th className="p-2 border border-border-color" colSpan={2}>Basis (d100)</th>
                                          <th className="p-2 border border-border-color">+Licht/Std</th>
                                      </tr>
                                  </thead>
                                  <tbody>
                                      {Object.entries(matrix.night).map(([area, data]) => {
                                          const defaults = DEFAULTS.night[area];
                                          return (
                                              <tr key={area}>
                                                  <td className="p-2 border border-border-color text-left font-semibold">{area}</td>
                                                  <td className="p-1 border border-border-color"><MatrixInput value={data.basis[0]} onChange={v => handleNightMatrixChange(area, 'basis', v, 0)} onReset={() => handleNightMatrixChange(area, 'basis', defaults.basis[0], 0)} /></td>
                                                  <td className="p-1 border border-border-color"><MatrixInput value={data.basis[1]} onChange={v => handleNightMatrixChange(area, 'basis', v, 1)} onReset={() => handleNightMatrixChange(area, 'basis', defaults.basis[1], 1)} /></td>
                                                  <td className="p-1 border border-border-color"><MatrixInput value={data.light} onChange={v => handleNightMatrixChange(area, 'light', v)} onReset={() => handleNightMatrixChange(area, 'light', defaults.light)} /></td>
                                              </tr>
                                          );
                                      })}
                                  </tbody>
                              </table>
                          </div>
                      </div>
                  </div>
              </section>
          );
      };

      const FlowPanel = ({ title, children }) => (
          <div className="bg-card rounded-xl p-4 shadow-lg">
              <h4 className="text-lg font-bold mb-4">{title}</h4>
              {children}
          </div>
      );

      const FlowPanels = ({ flowState, setFlowState, setResult, addLog, triggerModal }) => {
          const [localInput, setLocalInput] = useState({});
          const handleInputChange = (key, value) => setLocalInput(prev => ({ ...prev, [key]: value }));
          const cancelFlow = () => { setResult('Ablauf abgebrochen.'); setFlowState(null); };

          const panelContent = useMemo(() => {
              switch (flowState.step) {
                  case 'enemyStealthChoice': return (
                      <FlowPanel title="Versuchen die Gegner sich anzuschleichen?">
                          <div className="flex gap-2">
                              <button className="flex-1 bg-accent text-bg-secondary font-bold py-2 px-4 rounded-lg" onClick={() => setFlowState({ ...flowState, step: 'enemyStealthInput' })}>Ja</button>
                              <button className="flex-1 bg-transparent border border-border-color text-muted py-2 px-4 rounded-lg" onClick={() => {
                                  if (flowState.context === 'night') {
                                      setResult('Normale Begegnung. Wache bemerkt Gegner automatisch.');
                                      addLog('Nacht-Encounter ohne Gegner-Stealth ‚Üí alle wach');
                                      setFlowState(null);
                                  } else {
                                      setFlowState({ ...flowState, step: 'ppContest', enemyStealthAvg: null });
                                  }
                              }}>Nein</button>
                          </div>
                      </FlowPanel>
                  );
                  case 'enemyStealthInput': return (
                      <FlowPanel title="Gegner Stealth Rolls">
                          <input autoFocus placeholder="z.B. 12, 13, 14" value={localInput.enemyRolls || ''} onChange={e => handleInputChange('enemyRolls', e.target.value)} className="w-full p-2 mb-2 rounded-lg border border-border-color bg-input-bg text-white" />
                          <div className="flex gap-2">
                              <button className="flex-1 bg-accent text-bg-secondary font-bold py-2 px-4 rounded-lg" onClick={() => {
                                  const rolls = parseInts(localInput.enemyRolls || '');
                                  if (!rolls.length) return triggerModal('alert', 'Fehler', 'Bitte W√ºrfe eingeben.');
                                  const enemyStealthAvg = Math.round(avg(rolls));
                                  addLog(`Gegner Stealth: [${rolls.join(', ')}] ‚Üí √∏ ${enemyStealthAvg}`);
                                  setFlowState({ ...flowState, step: 'detection', enemyStealthAvg });
                              }}>Best√§tigen</button>
                              <button className="flex-1 bg-transparent border border-border-color text-muted py-2 px-4 rounded-lg" onClick={cancelFlow}>Abbrechen</button>
                          </div>
                      </FlowPanel>
                  );
                  case 'ppContest': return (
                      <FlowPanel title="Passive Perception Contest">
                          <div className="grid grid-cols-2 gap-4 mb-4">
                              <div>
                                  <label className="text-sm text-muted">H√∂chste PP der Gruppe</label>
                                  <input autoFocus type="number" min="1" value={localInput.playerPP || ''} onChange={e => handleInputChange('playerPP', e.target.value)} className="w-full p-2 rounded-lg border border-border-color bg-input-bg text-white" />
                              </div>
                               <div>
                                  <label className="text-sm text-muted">H√∂chste PP der Gegner</label>
                                  <input type="number" min="1" value={localInput.enemyPP || ''} onChange={e => handleInputChange('enemyPP', e.target.value)} className="w-full p-2 rounded-lg border border-border-color bg-input-bg text-white" />
                              </div>
                          </div>
                          <div className="flex gap-2">
                               <button className="flex-1 bg-accent text-bg-secondary font-bold py-2 px-4 rounded-lg" onClick={() => {
                                  const playerPP = parseInt(localInput.playerPP || '0');
                                  const enemyPP = parseInt(localInput.enemyPP || '0');
                                  if (!playerPP || !enemyPP) return triggerModal('alert', 'Fehler', 'Bitte g√ºltige PP-Werte eingeben.');
                                  addLog(`PP Contest: Spieler ${playerPP} vs Gegner ${enemyPP}`);
                                  if (playerPP > enemyPP) {
                                      setResult(`Spieler gewinnen (${playerPP} > ${enemyPP}) ‚Üí Gruppe kann schleichen`);
                                      setFlowState({...flowState, step: 'stealthChoice', winner: 'players', playerPP, enemyPP});
                                  } else if (enemyPP > playerPP) {
                                      setResult(`Gegner gewinnen (${enemyPP} > ${playerPP}) ‚Üí Gegner k√∂nnen schleichen`);
                                      setFlowState({...flowState, step: 'stealthChoice', winner: 'enemies', playerPP, enemyPP});
                                  } else {
                                      setResult(`Unentschieden (${playerPP} = ${enemyPP}) ‚Üí Normale Begegnung`);
                                      addLog('PP Contest unentschieden ‚Üí normale Begegnung');
                                      setFlowState(null);
                                  }
                               }}>Auswerten</button>
                              <button className="flex-1 bg-transparent border border-border-color text-muted py-2 px-4 rounded-lg" onClick={cancelFlow}>Abbrechen</button>
                          </div>
                      </FlowPanel>
                  );
                   case 'stealthChoice': return (
                      <FlowPanel title={flowState.winner === 'players' ? 'M√∂chte die Gruppe schleichen?' : 'Versuchen die Gegner zu schleichen?'}>
                          <p className="text-muted mb-4">{flowState.winner === 'players' ? 'Die Gruppe hat die Gegner zuerst bemerkt.' : 'Die Gegner haben die Gruppe zuerst bemerkt.'}</p>
                          {flowState.winner === 'players' && flowState.vehicle && <div className="p-2 mb-2 bg-bad/20 border border-bad/50 text-bad rounded-lg text-sm">‚ö†Ô∏è FAHRZEUG AKTIV: Alle Stealth-Checks mit Nachteil w√ºrfeln!</div>}
                           <div className="flex gap-2 mb-4">
                              <button className="flex-1 bg-accent text-bg-secondary font-bold py-2 px-4 rounded-lg" onClick={() => setFlowState({ ...flowState, step: 'stealthInput' })}>Ja, schleichen</button>
                              <button className="flex-1 bg-transparent border border-border-color text-muted py-2 px-4 rounded-lg" onClick={() => {
                                  setResult('Normale Begegnung (kein Stealth).');
                                  setFlowState(null);
                              }}>Nein, normale Begegnung</button>
                          </div>
                      </FlowPanel>
                  );
                  case 'stealthInput': return (
                      <FlowPanel title="Stealth Rolls eingeben">
                           <input autoFocus placeholder="z.B. 14, 13, 10, 18" value={localInput.stealthRolls || ''} onChange={e => handleInputChange('stealthRolls', e.target.value)} className="w-full p-2 mb-2 rounded-lg border border-border-color bg-input-bg text-white" />
                          <div className="flex gap-2">
                              <button className="flex-1 bg-accent text-bg-secondary font-bold py-2 px-4 rounded-lg" onClick={() => {
                                   const rolls = parseInts(localInput.stealthRolls || '');
                                  if (!rolls.length) return triggerModal('alert', 'Fehler', 'Bitte W√ºrfe eingeben.');
                                  const stealthAvg = Math.round(avg(rolls));
                                  addLog(`Stealth: [${rolls.join(', ')}] ‚Üí √∏ ${stealthAvg}`);
                                  setFlowState({ ...flowState, step: 'detection', stealthAvg });
                              }}>Auswerten</button>
                              <button className="flex-1 bg-transparent border border-border-color text-muted py-2 px-4 rounded-lg" onClick={cancelFlow}>Abbrechen</button>
                          </div>
                      </FlowPanel>
                  );
                  case 'detection':
                      const isNight = flowState.context === 'night';
                      const threshold = flowState.enemyStealthAvg ?? flowState.stealthAvg ?? 0;
                      let label = "Passive Perception Wert";
                      let defaultValue = "10";
                      if(isNight && flowState.watchPerception) {
                          label = `Aktive Perception der Wache (${flowState.affectedWatch?.name})`;
                          defaultValue = flowState.watchPerception.effectivePP.toString();
                      } else if(flowState.winner === 'players') {
                          label = "H√∂chste PP der Gegner";
                          defaultValue = flowState.enemyPP?.toString() ?? "10";
                      } else if (flowState.winner === 'enemies') {
                          label = "H√∂chste PP der Gruppe";
                          defaultValue = flowState.playerPP?.toString() ?? "10";
                      }

                      return (
                          <FlowPanel title="Detection Check">
                              <label className="text-sm text-muted">{label}</label>
                              <input autoFocus type="number" min="1" value={localInput.detectionPP ?? defaultValue} onChange={e => handleInputChange('detectionPP', e.target.value)} className="w-full p-2 mb-2 rounded-lg border border-border-color bg-input-bg text-white" />
                              <div className="flex gap-2">
                                  <button className="flex-1 bg-accent text-bg-secondary font-bold py-2 px-4 rounded-lg" onClick={() => {
                                      const detectionPP = parseInt(localInput.detectionPP ?? defaultValue);
                                      addLog(`Detection: PP ${detectionPP} vs Stealth ${threshold}`);
                                      if (detectionPP >= threshold) {
                                          setResult(isNight ? `Gegner erkannt! Wache weckt alle.` : `Stealth erkannt! Normale Begegnung.`);
                                          addLog(isNight ? `Gegner durch ${flowState.affectedWatch?.name} erkannt ‚Üí alle wach` : 'Stealth erkannt ‚Üí normale Begegnung');
                                      } else {
                                          if(isNight) {
                                               setResult(`Gruppe √ºberrascht! Nur ${flowState.affectedWatch?.name} ist wach.`);
                                               addLog(`Gruppe √ºberrascht ‚Üí nur ${flowState.affectedWatch?.name} wach`);
                                          } else if(flowState.winner === 'players'){
                                              setResult(`Begegnung vermieden! Erfolgreich geschlichen.`);
                                              addLog('Begegnung vermieden ‚Üí Gruppe erfolgreich geschlichen');
                                          } else {
                                              setResult(`Gruppe √ºberrascht! Gegner erfolgreich geschlichen.`);
                                              addLog('Gruppe √ºberrascht ‚Üí Gegner erfolgreich geschlichen');
                                          }
                                      }
                                      setFlowState(null);
                                  }}>Auswerten</button>
                                  <button className="flex-1 bg-transparent border border-border-color text-muted py-2 px-4 rounded-lg" onClick={cancelFlow}>Abbrechen</button>
                              </div>
                          </FlowPanel>
                      );
                  case 'nightEncounterInfo': return (
                      <FlowPanel title={`Nacht-Encounter: ${flowState.affectedWatch?.name}`}>
                           <div className="text-muted mb-4 space-y-1">
                              <p><strong>Vision:</strong> {flowState.affectedWatch?.vision ? VISION_NAMES[flowState.affectedWatch.vision] : 'N/A'}</p>
                              <p><strong>Effektive PP:</strong> {flowState.watchPerception?.effectivePP} ({flowState.watchPerception?.modifier})</p>
                           </div>
                           {flowState.affectedWatch?.vision === 'darkvision' && <div className="p-2 mb-2 bg-bad/20 border border-bad/50 text-bad rounded-lg text-sm">‚ö†Ô∏è DARKVISION AKTIV: Aktive Perception-Checks mit Nachteil w√ºrfeln!</div>}
                           <div className="flex gap-2">
                              <button className="flex-1 bg-accent text-bg-secondary font-bold py-2 px-4 rounded-lg" onClick={() => setFlowState({ ...flowState, step: 'enemyStealthChoice' })}>Stealth-Mechanik starten</button>
                              <button className="flex-1 bg-transparent border border-border-color text-muted py-2 px-4 rounded-lg" onClick={cancelFlow}>Abbrechen</button>
                          </div>
                      </FlowPanel>
                  );
                  default: return null;
              }
          }, [flowState, localInput, setFlowState, setResult, addLog, triggerModal]);

          if (!panelContent) return null;
          return <div className="mt-4">{panelContent}</div>;
      };

      const ResourceManager = ({ creatures, setCreatures, storages, setStorages, addLog, triggerModal, settings }) => {
          const [lastStoragesState, setLastStoragesState] = useState(null);
          const [lastCreaturesState, setLastCreaturesState] = useState(null);
          const [consumptionMsg, setConsumptionMsg] = useState(null);
          const [isHotWeather, setIsHotWeather] = useState(false);
          const [rationing, setRationing] = useState({ isOpen: false, selections: {} });

          const [forageState, setForageState] = useState({
              step: 'idle',
              dc: 15,
              wisMod: 0,
              checkResult: 0,
              foodFound: 0,
              waterFound: 0,
              mishap: false,
              selectedFoodStoreId: '',
              selectedWaterStoreId: '',
              isRanger: false
          });

          const getAvailableStorages = (type) => {
              return storages.filter(s => {
                  if (!s.isActive) return false;
                  if (s.storageType !== type) return false;
                  // Capacity check with 10lb multiplier for feed
                  const currentWeight = type === 'water' ? s.water : (s.food + (s.feed || 0) * FEED_WEIGHT_LB);
                  return currentWeight < s.maxCapacity;
              });
          };

          useEffect(() => {
              if (forageState.step === 'result') {
                  const availFood = getAvailableStorages('food_feed');
                  const availWater = getAvailableStorages('water');
                  
                  setForageState(prev => ({
                      ...prev,
                      selectedFoodStoreId: availFood.length > 0 ? availFood[0].id : '',
                      selectedWaterStoreId: availWater.length > 0 ? availWater[0].id : ''
                  }));
              }
          }, [forageState.step, storages]);

          const handleNumberChange = (id, field, valueStr, setter, list) => {
              setter((prev) => prev.map(item => {
                  if (item.id !== id) return item;
                  const num = valueStr === '' ? 0 : parseFloat(valueStr);
                  return { ...item, [field]: isNaN(num) ? 0 : num };
              }));
          };
          
          const handleStorageTypeChange = (id, newType) => {
              setStorages(prev => prev.map(s => {
                  if (s.id !== id) return s;
                  return {
                      ...s,
                      storageType: newType,
                      food: newType === 'water' ? 0 : s.food,
                      feed: newType === 'water' ? 0 : s.feed,
                      water: newType === 'food_feed' ? 0 : s.water
                  };
              }));
          };

          const addCreature = () => setCreatures(prev => [...prev, { id: generateId(), name: 'Neuer Charakter', size: 'Medium', usesFeed: false, conMod: 0, daysWithoutFood: 0, exhaustion: 0 }]);
          const updateCreature = (id, field, value) => setCreatures(prev => prev.map(c => c.id === id ? { ...c, [field]: value } : c));
          const removeCreature = (id) => { 
              triggerModal('confirm', 'L√∂schen', 'Eintrag wirklich l√∂schen?', () => {
                  setCreatures(prev => prev.filter(c => c.id !== id));
              });
          };

          const addStorage = () => setStorages(prev => [...prev, { id: generateId(), name: 'Neues Lager', isActive: true, storageType: 'food_feed', maxCapacity: 100, food: 0, water: 0, feed: 0 }]);
          const updateStorage = (id, field, value) => setStorages(prev => prev.map(s => s.id === id ? { ...s, [field]: value } : s));
          const removeStorage = (id) => { 
              triggerModal('confirm', 'Lager l√∂schen', 'Dieses Lager wirklich l√∂schen?', () => {
                  setStorages(prev => prev.filter(s => s.id !== id));
              });
          };

          const getRequirements = (c) => {
              const rate = CONSUMPTION_RATES[c.size] || CONSUMPTION_RATES['Medium'];
              const count = 1;
              const waterRate = isHotWeather ? rate.water * 2 : rate.water;
              
              return {
                  food: c.usesFeed ? 0 : (rate.food * count),
                  feed: c.usesFeed ? (rate.feed * count) : 0,
                  water: waterRate * count
              };
          };

          const totalNeeds = useMemo(() => {
              return creatures.reduce((acc, c) => {
                  const req = getRequirements(c);
                  return {
                      food: acc.food + req.food,
                      water: acc.water + req.water,
                      feed: acc.feed + req.feed
                  };
              }, { food: 0, water: 0, feed: 0 });
          }, [creatures, isHotWeather]);

          const totalStored = useMemo(() => {
              return storages.reduce((acc, s) => {
                  if (!s.isActive) return acc;
                  return {
                      food: acc.food + safeFloat(s.food),
                      water: acc.water + safeFloat(s.water),
                      feed: acc.feed + safeFloat(s.feed || 0)
                  };
              }, { food: 0, water: 0, feed: 0 });
          }, [storages]);

          const openRationingModal = () => {
              const initialSelections = {};
              creatures.forEach(c => {
                  initialSelections[c.id] = { food: true, water: true };
              });
              setRationing({ isOpen: true, selections: initialSelections });
          };

          const rationingTotals = useMemo(() => {
              if (!rationing.isOpen) return { food: 0, feed: 0, water: 0 };
              return creatures.reduce((acc, c) => {
                  const sel = rationing.selections[c.id];
                  if (!sel) return acc;
                  
                  const req = getRequirements(c);
                  return {
                      food: acc.food + (sel.food ? req.food : 0),
                      feed: acc.feed + (sel.food ? req.feed : 0),
                      water: acc.water + (sel.water ? req.water : 0)
                  };
              }, { food: 0, feed: 0, water: 0 });
          }, [rationing, creatures, isHotWeather]);

          const toggleSelection = (creatureId, type) => {
              setRationing(prev => ({
                  ...prev,
                  selections: {
                      ...prev.selections,
                      [creatureId]: {
                          ...prev.selections[creatureId],
                          [type]: !prev.selections[creatureId][type]
                      }
                  }
              }));
          };

          const confirmConsumption = () => {
              const needs = rationingTotals;
              const epsilon = 0.001;
              if (needs.food > totalStored.food + epsilon || 
                  needs.feed > totalStored.feed + epsilon || 
                  needs.water > totalStored.water + epsilon) {
                  return;
              }

              setLastStoragesState(JSON.parse(JSON.stringify(storages)));
              setLastCreaturesState(JSON.parse(JSON.stringify(creatures)));

              const newStorages = storages.map(s => ({...s}));
              let foodNeeded = needs.food;
              let feedNeeded = needs.feed;
              let waterNeeded = needs.water;

              for (const store of newStorages) {
                  if (!store.isActive) continue;

                  let sFood = safeFloat(store.food);
                  let sFeed = safeFloat(store.feed || 0);
                  let sWater = safeFloat(store.water);

                  if (foodNeeded > epsilon && sFood > epsilon) { const t = Math.min(sFood, foodNeeded); sFood -= t; foodNeeded -= t; }
                  if (feedNeeded > epsilon && sFeed > epsilon) { const t = Math.min(sFeed, feedNeeded); sFeed -= t; feedNeeded -= t; }
                  if (waterNeeded > epsilon && sWater > epsilon) { const t = Math.min(sWater, waterNeeded); sWater -= t; waterNeeded -= t; }

                  store.food = Math.round(sFood * 100) / 100;
                  store.feed = Math.round(sFeed * 100) / 100;
                  store.water = Math.round(sWater * 100) / 100;
              }
              setStorages(newStorages);

              const newCreatures = creatures.map(c => {
                  const sel = rationing.selections[c.id];
                  if (!sel) return c;
                  
                  let newDaysWithoutFood = c.daysWithoutFood;
                  let newExhaustion = c.exhaustion;
                  let gainedExhaustion = 0;
                  
                  if (!sel.food) {
                      newDaysWithoutFood = c.daysWithoutFood + 1;
                       const limit = Math.max(1, 3 + (c.conMod || 0));
                      if (newDaysWithoutFood > limit) gainedExhaustion++;
                  } else {
                      newDaysWithoutFood = 0;
                  }

                  if (!sel.water) {
                      gainedExhaustion += (c.exhaustion + gainedExhaustion > 0) ? 2 : 1;
                  }

                  newExhaustion += gainedExhaustion;

                  if (sel.food && sel.water && gainedExhaustion === 0 && c.exhaustion > 0) {
                      newExhaustion -= 1;
                  }
                  
                  newExhaustion = Math.min(6, Math.max(0, newExhaustion));

                  return {
                      ...c,
                      daysWithoutFood: newDaysWithoutFood,
                      exhaustion: newExhaustion
                  };
              });

              setCreatures(newCreatures);
              setRationing({ isOpen: false, selections: {} });
              
              const fedCount = Object.values(rationing.selections).filter(s => s.food).length;
              setConsumptionMsg(`Tagesabschluss: ${fedCount}/${creatures.length} versorgt.`);
              addLog(`Tagesabschluss durchgef√ºhrt.`);
              
              setTimeout(() => setConsumptionMsg(null), 5000);
          };

          const handleUndo = () => {
              if (!lastStoragesState || !lastCreaturesState) return;
              setStorages(lastStoragesState);
              setCreatures(lastCreaturesState);
              setLastStoragesState(null);
              setLastCreaturesState(null);
              setConsumptionMsg("R√ºckg√§ngig gemacht.");
              addLog("Tagesabschluss widerrufen.");
              setTimeout(() => setConsumptionMsg(null), 3000);
          };

          const startForaging = () => {
              // Restriction for fast pace removed by user request
              setForageState({ ...forageState, step: 'config', dc: 15, wisMod: 0, checkResult: 0, isRanger: false });
          };

          const handleWandererFeature = () => {
              setForageState(prev => ({ ...prev, step: 'result', foodFound: 6, waterFound: 6, mishap: false, checkResult: 999 }));
          };

          const handleCreateFoodSpell = () => {
              setForageState(prev => ({ ...prev, step: 'result', foodFound: 45, waterFound: 30, mishap: false, checkResult: 999 }));
          };

          const calculateForage = () => {
              const check = forageState.checkResult;
              const dc = forageState.dc;
              let food = 0;
              let water = 0;
              let mishap = false;
              const multiplier = forageState.isRanger ? 2 : 1;

              if (check >= dc) {
                  food = Math.max(0, rnd(6) + forageState.wisMod) * multiplier;
                  water = Math.max(0, rnd(6) + forageState.wisMod) * multiplier;
              } else if (check <= dc - 5) {
                  mishap = true;
              }

              setForageState(prev => ({ ...prev, step: 'result', foodFound: food, waterFound: water, mishap }));
          };

          const storeFood = () => {
              const targetId = forageState.selectedFoodStoreId;
              if(!targetId) return;
              const targetStorage = storages.find(s => s.id === targetId);
              if(!targetStorage) return;

              // Use FEED_WEIGHT_LB for capacity check
              const currentLoad = targetStorage.food + (targetStorage.feed || 0) * FEED_WEIGHT_LB;
              const space = targetStorage.maxCapacity - currentLoad;
              const toAdd = Math.min(space, forageState.foodFound);

              if(toAdd <= 0) {
                  triggerModal('alert', 'Voll', 'Dieses Lager ist voll.');
                  return;
              }

              setStorages(prev => prev.map(s => s.id === targetId ? { ...s, food: s.food + toAdd } : s));
              setForageState(prev => ({ ...prev, foodFound: prev.foodFound - toAdd }));
          };

          const storeWater = () => {
              const targetId = forageState.selectedWaterStoreId;
              if(!targetId) return;
              const targetStorage = storages.find(s => s.id === targetId);
              if(!targetStorage) return;

              const space = targetStorage.maxCapacity - targetStorage.water;
              const toAdd = Math.min(space, forageState.waterFound);

              if(toAdd <= 0) {
                  triggerModal('alert', 'Voll', 'Dieses Lager ist voll.');
                  return;
              }

              setStorages(prev => prev.map(s => s.id === targetId ? { ...s, water: s.water + toAdd } : s));
              setForageState(prev => ({ ...prev, waterFound: prev.waterFound - toAdd }));
          };
          
          const discardRemainingForage = () => {
              triggerModal('confirm', 'Rest wegwerfen?', `M√∂chtest du ${forageState.foodFound}lb Essen und ${forageState.waterFound}gal Wasser zur√ºcklassen?`, () => {
                   setForageState(prev => ({...prev, step: 'idle'}));
              });
          }

          return (
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                  
                  {/* Rationing Modal */}
                  {rationing.isOpen && (
                       <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-200">
                          <div className="bg-card border border-border-color rounded-xl shadow-2xl max-w-2xl w-full p-6 flex flex-col max-h-[90vh]">
                              <h3 className="text-xl font-bold mb-4 text-white">Rationierung & Verbrauch</h3>
                              
                              <div className="grid grid-cols-3 gap-4 mb-4 text-center bg-glass p-3 rounded-lg">
                                  <div>
                                      <div className="text-xs text-muted">Essen (lb)</div>
                                      <div className={`${rationingTotals.food > totalStored.food ? 'text-bad' : 'text-white'} font-bold`}>
                                          {rationingTotals.food.toFixed(1)} / {totalStored.food.toFixed(1)}
                                      </div>
                                  </div>
                                  <div>
                                      <div className="text-xs text-muted">Tierfutter (Unit)</div>
                                      <div className={`${rationingTotals.feed > totalStored.feed ? 'text-bad' : 'text-white'} font-bold`}>
                                          {rationingTotals.feed.toFixed(1)} / {totalStored.feed.toFixed(1)}
                                      </div>
                                  </div>
                                  <div>
                                      <div className="text-xs text-muted">Wasser (gal)</div>
                                      <div className={`${rationingTotals.water > totalStored.water ? 'text-bad' : 'text-white'} font-bold`}>
                                          {rationingTotals.water.toFixed(1)} / {totalStored.water.toFixed(1)}
                                      </div>
                                  </div>
                              </div>

                              <div className="overflow-y-auto flex-grow mb-4 border border-border-color rounded-lg">
                                  <table className="w-full text-sm text-left">
                                      <thead className="bg-white/5 text-muted sticky top-0">
                                          <tr>
                                              <th className="p-3">Name</th>
                                              <th className="p-3 text-center">Hunger / Exhaustion</th>
                                              <th className="p-3 text-center">Essen</th>
                                              <th className="p-3 text-center">Wasser</th>
                                          </tr>
                                      </thead>
                                      <tbody className="divide-y divide-border-color">
                                          {creatures.map(c => {
                                              const req = getRequirements(c);
                                              const sel = rationing.selections[c.id];
                                              if(!sel) return null;
                                              
                                              const willStarve = !sel.food && (c.daysWithoutFood + 1 > 3 + (c.conMod || 0));
                                              const willDehydrate = !sel.water;
                                              
                                              return (
                                                  <tr key={c.id} className="hover:bg-white/5">
                                                      <td className="p-3 font-medium">{c.name}</td>
                                                      <td className="p-3 text-center">
                                                          <div className="flex justify-center gap-2">
                                                              {c.daysWithoutFood > 0 && <span className="text-orange-400 text-xs px-1.5 py-0.5 bg-orange-400/10 rounded">Hunger {c.daysWithoutFood}d</span>}
                                                              {c.exhaustion > 0 && <span className="text-bad text-xs px-1.5 py-0.5 bg-bad/10 rounded">üíÄ Lv {c.exhaustion}</span>}
                                                              {c.daysWithoutFood === 0 && c.exhaustion === 0 && <span className="text-muted text-xs">-</span>}
                                                          </div>
                                                      </td>
                                                      <td className="p-3 text-center">
                                                          <label className="flex flex-col items-center cursor-pointer group">
                                                              <input type="checkbox" checked={sel.food} onChange={() => toggleSelection(c.id, 'food')} className="w-5 h-5 rounded border-border-color bg-input-bg checked:bg-good mb-1" />
                                                              <span className="text-xs text-muted group-hover:text-white">
                                                                  {c.usesFeed ? `${req.feed} Unit` : `${req.food} lb`}
                                                              </span>
                                                          </label>
                                                      </td>
                                                      <td className="p-3 text-center">
                                                           <label className="flex flex-col items-center cursor-pointer group">
                                                              <input type="checkbox" checked={sel.water} onChange={() => toggleSelection(c.id, 'water')} className="w-5 h-5 rounded border-border-color bg-input-bg checked:bg-accent mb-1" />
                                                              <span className="text-xs text-muted group-hover:text-white">
                                                                  {req.water} gal
                                                              </span>
                                                          </label>
                                                      </td>
                                                  </tr>
                                              );
                                          })}
                                      </tbody>
                                  </table>
                              </div>

                              <div className="flex gap-2">
                                  <button onClick={confirmConsumption} disabled={rationingTotals.food > totalStored.food + 0.001 || rationingTotals.feed > totalStored.feed + 0.001 || rationingTotals.water > totalStored.water + 0.001} className="flex-1 bg-gradient-to-r from-orange-500 to-red-500 text-white font-bold py-3 rounded-lg shadow-md disabled:opacity-50 disabled:cursor-not-allowed">Best√§tigen & Konsequenzen anwenden</button>
                                  <button onClick={() => setRationing({isOpen: false, selections: {}})} className="px-4 py-3 border border-border-color rounded-lg text-muted hover:bg-glass">Abbrechen</button>
                              </div>
                          </div>
                       </div>
                  )}

                  {/* Foraging Modal */}
                  {forageState.step !== 'idle' && (
                      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-200">
                          <div className="bg-card border border-border-color rounded-xl shadow-2xl max-w-md w-full p-6 max-h-[90vh] overflow-y-auto">
                              {forageState.step === 'config' && (
                                  <>
                                      <h3 className="text-xl font-bold mb-4 text-white">Nahrungssuche: Einstellungen</h3>
                                      <div className="space-y-4 mb-6">
                                          <div>
                                              <label className="text-sm text-muted block mb-2">Verf√ºgbarkeit (DC)</label>
                                              <div className="grid grid-cols-3 gap-2">
                                                  <button onClick={() => setForageState(prev => ({...prev, dc: 10}))} className={`p-2 rounded border border-border-color text-sm ${forageState.dc === 10 ? 'bg-accent text-bg-secondary font-bold' : 'bg-input-bg text-muted'}`}>Reichlich</button>
                                                  <button onClick={() => setForageState(prev => ({...prev, dc: 15}))} className={`p-2 rounded border border-border-color text-sm ${forageState.dc === 15 ? 'bg-accent text-bg-secondary font-bold' : 'bg-input-bg text-muted'}`}>Begrenzt</button>
                                                  <button onClick={() => setForageState(prev => ({...prev, dc: 20}))} className={`p-2 rounded border border-border-color text-sm ${forageState.dc === 20 ? 'bg-accent text-bg-secondary font-bold' : 'bg-input-bg text-muted'}`}>Karg</button>
                                              </div>
                                          </div>
                                          <div>
                                              <label className="text-sm text-muted block mb-1">Wisdom (Survival) Modifier</label>
                                              <input type="number" value={forageState.wisMod} onChange={e => setForageState(prev => ({...prev, wisMod: parseInt(e.target.value)||0}))} className="w-full bg-input-bg rounded p-2 text-white border border-border-color" />
                                          </div>
                                          <div className="border-t border-border-color pt-4">
                                              <div className="flex items-center gap-2 mb-3">
                                                  <input type="checkbox" id="rangerCheck" checked={forageState.isRanger} onChange={e => setForageState(prev => ({...prev, isRanger: e.target.checked}))} className="w-4 h-4 rounded" />
                                                  <label htmlFor="rangerCheck" className="text-sm text-muted">Natural Explorer (x2)</label>
                                              </div>
                                              <div className="grid grid-cols-1 gap-2">
                                                  <button onClick={handleWandererFeature} className="text-left px-3 py-2 bg-glass border border-border-color rounded text-sm text-accent">üåç Wanderer (Outlander)</button>
                                                  <button onClick={handleCreateFoodSpell} className="text-left px-3 py-2 bg-glass border border-border-color rounded text-sm text-purple-400">‚ú® Create Food & Water</button>
                                              </div>
                                          </div>
                                      </div>
                                      <div className="flex gap-2">
                                          <button onClick={() => setForageState(prev => ({...prev, step: 'input'}))} className="flex-1 bg-accent text-bg-secondary font-bold py-2 rounded-lg">W√ºrfeln</button>
                                          <button onClick={() => setForageState(prev => ({...prev, step: 'idle'}))} className="flex-1 border border-border-color text-muted py-2 rounded-lg">Abbrechen</button>
                                      </div>
                                  </>
                              )}
                              {forageState.step === 'input' && (
                                  <>
                                      <h3 className="text-xl font-bold mb-4 text-white">Survival Check</h3>
                                      <input autoFocus type="number" min="1" onChange={e => setForageState(prev => ({...prev, checkResult: parseInt(e.target.value)||0}))} className="w-full bg-input-bg rounded p-3 text-xl text-center text-white mb-6" placeholder="0" />
                                      <div className="flex gap-2">
                                          <button onClick={calculateForage} className="flex-1 bg-accent text-bg-secondary font-bold py-2 rounded-lg">Check auswerten</button>
                                      </div>
                                  </>
                              )}
                               {forageState.step === 'result' && (
                                  <>
                                      <h3 className="text-xl font-bold mb-4 text-white">Ergebnis</h3>
                                      <div className="mb-6 bg-glass p-4 rounded-lg text-center">
                                          {forageState.mishap ? <div className="text-bad font-bold">MISSGESCHICK!</div> : 
                                          <div className="text-white">Gefunden: {forageState.foodFound}lb Essen, {forageState.waterFound}gal Wasser</div>}
                                      </div>

                                      {!forageState.mishap && (
                                          <div className="space-y-4 mb-4">
                                              {forageState.foodFound > 0 && (
                                                  <div className="bg-glass p-3 rounded-lg">
                                                      <label className="text-xs text-muted block mb-1">Essen einlagern ({forageState.foodFound} lb)</label>
                                                      <div className="flex gap-2">
                                                          <select value={forageState.selectedFoodStoreId} onChange={e => setForageState(prev => ({...prev, selectedFoodStoreId: e.target.value}))} className="flex-grow bg-bg-secondary text-white p-2 rounded text-sm">
                                                              {getAvailableStorages('food_feed').map(s => {
                                                                  const currentLoad = s.food + (s.feed||0) * FEED_WEIGHT_LB;
                                                                  return <option key={s.id} value={s.id}>{s.name} (Frei: {(s.maxCapacity - currentLoad).toFixed(1)}lb)</option>
                                                              })}
                                                          </select>
                                                          <button onClick={storeFood} className="bg-good text-bg-secondary px-3 py-1 rounded text-sm font-bold">OK</button>
                                                      </div>
                                                  </div>
                                              )}
                                              {forageState.waterFound > 0 && (
                                                  <div className="bg-glass p-3 rounded-lg">
                                                      <label className="text-xs text-muted block mb-1">Wasser einlagern ({forageState.waterFound} gal)</label>
                                                      <div className="flex gap-2">
                                                          <select value={forageState.selectedWaterStoreId} onChange={e => setForageState(prev => ({...prev, selectedWaterStoreId: e.target.value}))} className="flex-grow bg-bg-secondary text-white p-2 rounded text-sm">
                                                              {getAvailableStorages('water').map(s => <option key={s.id} value={s.id}>{s.name} (Frei: {(s.maxCapacity - s.water).toFixed(1)}gal)</option>)}
                                                          </select>
                                                          <button onClick={storeWater} className="bg-accent text-bg-secondary px-3 py-1 rounded text-sm font-bold">OK</button>
                                                      </div>
                                                  </div>
                                              )}
                                          </div>
                                      )}
                                      <button onClick={discardRemainingForage} className="w-full bg-accent text-bg-secondary font-bold py-2 rounded-lg">Schlie√üen</button>
                                  </>
                              )}
                          </div>
                      </div>
                  )}

                  <div className="space-y-4">
                      <div className="bg-card rounded-xl p-4 shadow-lg">
                          <div className="flex justify-between items-center mb-4">
                              <h3 className="text-xl font-bold">Verbraucher</h3>
                              <div className="flex items-center gap-2">
                                  <button onClick={() => setIsHotWeather(!isHotWeather)} className={`text-xs px-2 py-1 rounded border ${isHotWeather ? 'bg-orange-500/20 text-orange-400 border-orange-500' : 'text-muted'}`}>{isHotWeather ? '‚òÄÔ∏è Hei√ü' : '‚òÅÔ∏è Normal'}</button>
                                  <button onClick={addCreature} className="text-xs bg-glass px-2 py-1 rounded border">+ Neu</button>
                              </div>
                          </div>
                          
                          <div className="space-y-2">
                              {creatures.map(c => (
                                  <div key={c.id} className="grid grid-cols-[auto,1fr,auto,80px,30px] gap-2 items-center bg-glass p-2 rounded">
                                      <div className="flex flex-col gap-0.5">
                                          {c.daysWithoutFood > 0 && <span className="text-[10px] text-white bg-orange-500/50 px-1 rounded text-center">üçî{c.daysWithoutFood}</span>}
                                          {c.exhaustion > 0 && <span className="text-[10px] text-white bg-bad px-1 rounded text-center">üíÄ{c.exhaustion}</span>}
                                      </div>
                                      <input className="bg-transparent text-sm text-white outline-none" value={c.name} onChange={e => updateCreature(c.id, 'name', e.target.value)} placeholder="Name" />
                                      <button onClick={() => updateCreature(c.id, 'usesFeed', !c.usesFeed)} className={`p-1.5 rounded ${c.usesFeed ? 'bg-yellow-600 text-white' : 'bg-input-bg text-muted'}`}>üêæ</button>
                                      <select className="bg-bg-secondary text-xs rounded p-1 border border-border-color text-white" value={c.size} onChange={e => updateCreature(c.id, 'size', e.target.value)}>
                                          {Object.keys(CONSUMPTION_RATES).map(size => <option key={size} value={size}>{size}</option>)}
                                      </select>
                                      <button onClick={() => removeCreature(c.id)} className="text-muted">√ó</button>
                                  </div>
                              ))}
                          </div>
                      </div>

                      <div className="bg-card rounded-xl p-4 shadow-lg border border-border-color">
                          <h3 className="text-lg font-bold mb-3">Tagesabschluss</h3>
                          <div className="text-sm space-y-1 mb-4">
                              <div className="flex justify-between"><span className="text-muted">Bedarf:</span> <span>üçî {totalNeeds.food.toFixed(1)} / üåæ {totalNeeds.feed.toFixed(1)} / üíß {totalNeeds.water.toFixed(1)}</span></div>
                              <div className="flex justify-between"><span className="text-muted">Vorrat:</span> <span>üçî {totalStored.food.toFixed(1)} / üåæ {totalStored.feed.toFixed(1)} / üíß {totalStored.water.toFixed(1)}</span></div>
                          </div>
                          <button onClick={openRationingModal} disabled={creatures.length === 0} className="w-full bg-gradient-to-r from-orange-500 to-red-500 text-white font-bold py-3 rounded-lg">Tagesration verbrauchen</button>
                          {lastStoragesState && <button onClick={handleUndo} className="w-full mt-2 text-muted text-sm hover:text-white transition-colors">Widerrufen</button>}
                      </div>
                  </div>

                  <div className="bg-card rounded-xl p-4 shadow-lg h-fit">
                      <div className="flex justify-between items-center mb-4">
                          <h3 className="text-xl font-bold">Lager & Vorr√§te</h3>
                          <div className="flex gap-2">
                              <button onClick={startForaging} className="text-xs bg-green-700 text-white px-2 py-1 rounded">üåø Suchen</button>
                              <button onClick={addStorage} className="text-xs bg-glass px-2 py-1 rounded border">+ Lager</button>
                          </div>
                      </div>

                      <div className="space-y-3">
                          {storages.map(s => {
                              // Feed weighs 10x more than regular food
                              const currentLoad = s.storageType === 'water' ? s.water : (s.food + (s.feed||0) * FEED_WEIGHT_LB);
                              const isFull = currentLoad >= s.maxCapacity;
                              
                              return (
                                  <div key={s.id} className={`bg-glass p-3 rounded-lg border ${!s.isActive ? 'opacity-50 grayscale' : ''}`}>
                                      <div className="flex justify-between items-center mb-2">
                                          <div className="flex items-center gap-2 flex-grow">
                                              <button onClick={() => updateStorage(s.id, 'isActive', !s.isActive)} className={`p-1 rounded text-[10px] border ${s.isActive ? 'text-good border-good/30' : 'text-muted'}`}>{s.isActive ? 'Aktiv' : 'Inaktiv'}</button>
                                              <input className="font-bold bg-transparent text-white outline-none w-full" value={s.name} onChange={e => updateStorage(s.id, 'name', e.target.value)} />
                                          </div>
                                          <button onClick={() => removeStorage(s.id)} className="text-muted">√ó</button>
                                      </div>
                                      
                                      <div className="flex justify-between text-[10px] text-muted mb-1">
                                          <div className="flex bg-input-bg rounded p-0.5">
                                              <button onClick={() => handleStorageTypeChange(s.id, 'food_feed')} className={`px-2 py-0.5 rounded ${s.storageType === 'food_feed' ? 'bg-accent text-bg-secondary font-bold' : ''}`}>Essen</button>
                                              <button onClick={() => handleStorageTypeChange(s.id, 'water')} className={`px-2 py-0.5 rounded ${s.storageType === 'water' ? 'bg-accent text-bg-secondary font-bold' : ''}`}>Wasser</button>
                                          </div>
                                          <div>Kapazit√§t: <input type="number" step="1" value={s.maxCapacity} onChange={e => handleNumberChange(s.id, 'maxCapacity', e.target.value, setStorages, storages)} className="w-10 bg-transparent text-white text-right" /> {s.storageType === 'water' ? 'gal' : 'lb'}</div>
                                      </div>

                                      <div className="w-full bg-input-bg h-1 rounded-full overflow-hidden mb-3">
                                          <div className={`h-full ${isFull ? 'bg-bad' : 'bg-good'}`} style={{ width: `${Math.min(100, (currentLoad / s.maxCapacity) * 100)}%` }}></div>
                                      </div>

                                      <div className="grid grid-cols-2 gap-2">
                                          {s.storageType === 'food_feed' ? (
                                              <>
                                                  <div>
                                                      <label className="text-[10px] text-muted block">Essen (lb)</label>
                                                      <input type="number" step="1" className="w-full bg-input-bg rounded p-1 text-sm text-white" value={s.food} onChange={e => handleNumberChange(s.id, 'food', e.target.value, setStorages, storages)} />
                                                  </div>
                                                  <div>
                                                      <label className="text-[10px] text-muted block">Futter (Unit)</label>
                                                      <input type="number" step="1" className="w-full bg-input-bg rounded p-1 text-sm text-white" value={s.feed || 0} onChange={e => handleNumberChange(s.id, 'feed', e.target.value, setStorages, storages)} />
                                                  </div>
                                              </>
                                          ) : (
                                               <div className="col-span-2">
                                                  <label className="text-[10px] text-muted block">Wasser (gal)</label>
                                                  <input type="number" step="1" className="w-full bg-input-bg rounded p-1 text-sm text-white" value={s.water} onChange={e => handleNumberChange(s.id, 'water', e.target.value, setStorages, storages)} />
                                              </div>
                                          )}
                                      </div>
                                  </div>
                              );
                          })}
                      </div>
                  </div>
              </div>
          );
      };

      // ==========================================
      // MAIN APP
      // ==========================================

      const App = () => {
          const [activeTab, setActiveTab] = useState('encounters');
          const [log, setLog] = useState(['Optimiertes Tool geladen.']);
          const [result, setResult] = useState('Keine W√ºrfe bisher.');
          const [currentFlow, setCurrentFlow] = useState(null);
          const [modalConfig, setModalConfig] = useState({ isOpen: false, type: 'alert', title: '', message: '' });

          const triggerModal = (type, title, message, onConfirm) => setModalConfig({ isOpen: true, type, title, message, onConfirm });

          const loadData = (key, defaultValue) => {
              try {
                  const item = localStorage.getItem(`enc_${key}`);
                  return item ? JSON.parse(item) : defaultValue;
              } catch (e) { return defaultValue; }
          };

          const [settings, setSettings] = useState(() => loadData('state', { terrain: 'road', pace: 'normal', vehicle: 'no', watchCount: 3, lightHours: 0, watches: Array(3).fill({ name: '', vision: 'none', pp: 12 }) }));
          const [matrix, setMatrix] = useState(() => loadData('matrix', JSON.parse(JSON.stringify(DEFAULTS))));
          const [creatures, setCreatures] = useState(() => loadData('creatures', [{ id: '1', name: 'Pferd', size: 'Large', usesFeed: true, conMod: 2, daysWithoutFood: 0, exhaustion: 0 }, { id: '2', name: 'Abenteurer', size: 'Medium', usesFeed: false, conMod: 1, daysWithoutFood: 0, exhaustion: 0 }]));
          const [storages, setStorages] = useState(() => loadData('storages', [{ id: '1', name: 'Wagen', isActive: true, storageType: 'food_feed', maxCapacity: 200, food: 50, water: 20, feed: 7 }]));

          useEffect(() => { localStorage.setItem('enc_state', JSON.stringify(settings)); }, [settings]);
          useEffect(() => { localStorage.setItem('enc_matrix', JSON.stringify(matrix)); }, [matrix]);
          useEffect(() => { localStorage.setItem('enc_creatures', JSON.stringify(creatures)); }, [creatures]);
          useEffect(() => { localStorage.setItem('enc_storages', JSON.stringify(storages)); }, [storages]);
          
          const addLog = (msg) => setLog(prev => [`${new Date().toLocaleTimeString()} ‚Äî ${msg}`, ...prev]);
          const resetLog = () => { setLog([]); setResult('Log geleert.'); setCurrentFlow(null); };

          const resetAll = () => {
              triggerModal('confirm', 'Alles zur√ºcksetzen', 'Alles auf Standard zur√ºcksetzen?', () => {
                  localStorage.removeItem('enc_state');
                  localStorage.removeItem('enc_matrix');
                  location.reload();
              });
          };

          const handleTravelRoll = () => {
              resetLog();
              const ranges = matrix.day[TERRAIN_MAP[settings.terrain]];
              const d = rnd(100);
              let encType = null;
              if (d >= ranges.hostile[0] && d <= ranges.hostile[1]) encType = 'hostile';
              else if (d >= ranges.neutral[0] && d <= ranges.neutral[1]) encType = 'neutral';
              else if (d >= ranges.poi[0] && d <= ranges.poi[1]) encType = 'poi';

              if (!encType) { setResult('Keine Begegnung.'); return; }
              setResult(`Encounter: ${encType.toUpperCase()} (d100 ${d})`);
              if(encType !== 'poi') setCurrentFlow({ step: 'enemyStealthChoice', context: 'day', encounterType: encType, d, vehicle: settings.vehicle === 'yes' });
          };
          
          const handleRestRoll = () => {
              resetLog();
              const nightInfo = matrix.night[TERRAIN_MAP[settings.terrain]];
              const threshold = Math.max(nightInfo.basis[0], nightInfo.basis[1]) + (settings.lightHours * nightInfo.light);
              const d = rnd(100);
              if (d > threshold) { setResult('Keine Begegnung w√§hrend der Nacht.'); return; }
              const watchRoll = rnd(settings.watches.length);
              const affectedWatch = settings.watches[watchRoll - 1];
              setCurrentFlow({ step: 'nightEncounterInfo', context: 'night', encounterType: 'hostile', d, affectedWatch, watchPerception: { effectivePP: affectedWatch.pp, modifier: 'Normal' } });
          };

          return (
              <main className="min-h-screen p-4 md:p-7 pb-20">
                  <Modal config={modalConfig} onClose={() => setModalConfig({...modalConfig, isOpen: false})} />
                  <div className="max-w-7xl mx-auto">
                      <header className="mb-6 flex justify-between items-center">
                          <h1 className="text-2xl font-bold">Random Encounters</h1>
                          <div className="flex bg-card p-1 rounded-lg border border-border-color">
                              <button onClick={() => setActiveTab('encounters')} className={`px-4 py-2 rounded-md text-sm font-bold ${activeTab === 'encounters' ? 'bg-accent text-bg-secondary' : 'text-muted'}`}>üé≤ Begegnungen</button>
                              <button onClick={() => setActiveTab('resources')} className={`px-4 py-2 rounded-md text-sm font-bold ${activeTab === 'resources' ? 'bg-accent text-bg-secondary' : 'text-muted'}`}>üçé Ressourcen</button>
                          </div>
                      </header>
                      
                      {activeTab === 'encounters' ? (
                          <>
                              <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
                                  <div className="lg:col-span-2"><SettingsCard settings={settings} setSettings={setSettings} onTravelRoll={handleTravelRoll} onRestRoll={handleRestRoll} onResetAll={resetAll} /></div>
                                  <LogCard log={log} result={result} onResetLog={resetLog} />
                              </div>
                              {currentFlow && <FlowPanels flowState={currentFlow} setFlowState={setCurrentFlow} setResult={setResult} addLog={addLog} triggerModal={triggerModal} />}
                              <MatrixEditor matrix={matrix} setMatrix={setMatrix} addLog={addLog} triggerModal={triggerModal} />
                          </>
                      ) : (
                          <ResourceManager creatures={creatures} setCreatures={setCreatures} storages={storages} setStorages={setStorages} addLog={addLog} triggerModal={triggerModal} settings={settings} />
                      )}
                  </div>
              </main>
          );
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<React.StrictMode><App /></React.StrictMode>);
    </script>
  </body>
</html>